---
phase: 01-jj-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [get-shit-done/references/jj-integration.md]
autonomous: true
---

<objective>
Create JJ integration reference document with commit workflow, command mappings, and repo detection patterns.

Purpose: Establish the JJ equivalent of git-integration.md that all subsequent workflow updates will reference. This is the foundation for replacing git commands throughout GSD.
Output: Complete `jj-integration.md` reference document ready for use by Phase 2 workflow updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing git integration (use as structural template):
@get-shit-done/references/git-integration.md

# Style guide for GSD documents:
@GSD-STYLE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create jj-integration.md structure with core principle and commit points</name>
  <files>get-shit-done/references/jj-integration.md</files>
  <action>
Create new file `get-shit-done/references/jj-integration.md` following the structure of git-integration.md but adapted for JJ:

1. `<overview>` - JJ integration for GSD framework
2. `<core_principle>` - Same as git: "Commit outcomes, not process"
3. `<commit_points>` - Same table (BRIEF+ROADMAP=YES, Task=YES, Plan=YES, etc.)
4. `<jj_check>` - Detection logic for JJ repos:
   ```bash
   # Check for JJ repo (colocated or native)
   [ -d .jj ] && echo "JJ_EXISTS" || echo "NO_JJ"

   # Check if colocated (has both .jj and .git)
   [ -d .jj ] && [ -d .git ] && echo "COLOCATED" || echo "NATIVE"
   ```
   If NO_JJ: Run `jj git init --colocate` for new GSD projects (maintains GitHub compatibility).

Use same XML tag structure and markdown conventions as git-integration.md.
  </action>
  <verify>File exists at get-shit-done/references/jj-integration.md with overview, core_principle, commit_points, and jj_check sections</verify>
  <done>jj-integration.md created with foundational sections matching git-integration.md structure</done>
</task>

<task type="auto">
  <name>Task 2: Document JJ commit workflow and formats</name>
  <files>get-shit-done/references/jj-integration.md</files>
  <action>
Add `<commit_formats>` section with JJ-specific commands. Key differences from git:

**Initialization format:**
```bash
# JJ uses describe to set message on working copy, then new to finalize
jj describe -m "docs: initialize [project-name] ([N] phases)

[One-liner from PROJECT.md]

Phases:
1. [phase-name]: [goal]
..."

# Stage and finalize the commit
jj new

# Push to remote (if configured)
jj git push --bookmark main --allow-new
```

**Task completion format:**
```bash
# JJ workflow: describe current working copy, then create new commit
jj describe -m "{type}({phase}-{plan}): {task-name}

- [Key change 1]
- [Key change 2]
"

# Finalize and move to fresh working copy
jj new
```

**Plan completion format:**
```bash
# Same pattern - describe then new
jj describe -m "docs({phase}-{plan}): complete [plan-name] plan

Tasks completed: [N]/[N]
- [Task 1]
- [Task 2]
"
jj new
```

**Key insight:** JJ's `jj commit -m "msg"` is shorthand for `jj describe -m "msg" && jj new`. Use either approach consistently.

Include note: Unlike git, JJ automatically tracks all file changes - no `jj add` step needed.
  </action>
  <verify>File contains commit_formats section with initialization, task-completion, and plan-completion formats using jj describe/new pattern</verify>
  <done>JJ commit workflow documented with all three commit format types</done>
</task>

<task type="auto">
  <name>Task 3: Add command mappings, example log, and rationale</name>
  <files>get-shit-done/references/jj-integration.md</files>
  <action>
Complete the document with remaining sections:

1. `<command_mapping>` - Git to JJ translation table:
   | Git Command | JJ Equivalent | Notes |
   |-------------|---------------|-------|
   | `git init` | `jj git init --colocate` | Creates both .jj and .git |
   | `git add .` | (automatic) | JJ auto-tracks all changes |
   | `git commit -m "msg"` | `jj commit -m "msg"` | Or: jj describe + jj new |
   | `git commit --amend` | `jj describe -m "msg"` | Updates current working copy |
   | `git status` | `jj status` | Shows working copy changes |
   | `git log` | `jj log` | Shows change IDs + commit IDs |
   | `git push` | `jj git push --bookmark <name>` | Bookmarks = branches |
   | `git fetch` | `jj git fetch` | Fetches from all remotes |
   | `git pull` | `jj git fetch && jj rebase -d main@origin` | No direct pull equivalent |
   | `[ -d .git ]` | `[ -d .jj ]` | Repo detection |

2. `<example_log>` - Same structure as git version showing per-task commits

3. `<anti_patterns>` - Same principles (don't commit PLAN.md creation, do commit task completion)

4. `<commit_strategy_rationale>` - Same as git (context engineering, failure recovery, debugging, observability)

5. `<jj_specific_notes>` - New section:
   - Working copy IS a commit (no staging area concept)
   - Change IDs persist through rebases (more stable than commit hashes)
   - Conflicts can be committed and resolved later
   - Use `jj git push --allow-new` for first push of a bookmark
   - Bookmarks auto-follow commits during rebase (unlike git branches)
  </action>
  <verify>File contains all sections: command_mapping, example_log, anti_patterns, commit_strategy_rationale, jj_specific_notes</verify>
  <done>Complete jj-integration.md with all sections, ready for Phase 2 workflow updates</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] File exists at `get-shit-done/references/jj-integration.md`
- [ ] Document has same section structure as git-integration.md
- [ ] JJ commands are accurate (jj describe, jj new, jj commit)
- [ ] Colocated vs native detection logic is correct
- [ ] Command mapping table covers all git commands used in GSD
- [ ] Follows GSD-STYLE.md conventions (XML tags, markdown, tone)
</verification>

<success_criteria>
- All tasks completed
- jj-integration.md is complete and self-contained
- Document can serve as single reference for all JJ operations in GSD
- No git commands remain in the new document
</success_criteria>

<output>
After completion, create `.planning/phases/01-jj-foundation/01-01-SUMMARY.md`
</output>
